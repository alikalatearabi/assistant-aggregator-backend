import { Test, TestingModule } from '@nestjs/testing';
import { ChatMessagesService } from './chat-messages.service';
import { ChatMessagesGateway } from '../gateways/chat-messages.gateway';
import { ChatMessagesRequestDto, ChatMessagesResponseMode } from '../dto/chat-messages.dto';
import axios from 'axios';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('ChatMessagesService', () => {
  let service: ChatMessagesService;
  let gateway: ChatMessagesGateway;

  const mockGateway = {
    broadcast: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ChatMessagesService,
        {
          provide: ChatMessagesGateway,
          useValue: mockGateway,
        },
      ],
    }).compile();

    service = module.get<ChatMessagesService>(ChatMessagesService);
    gateway = module.get<ChatMessagesGateway>(ChatMessagesGateway);

    // Clear all mocks
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('processBlocking', () => {
    const mockRequest: ChatMessagesRequestDto = {
      query: 'What is the capital of France?',
      inputs: {
        similarityThreshold: '0.8',
        contextCount: 5,
      },
      responseMode: ChatMessagesResponseMode.BLOCKING,
      user: '507f1f77bcf86cd799439012',
      autoGeneratedName: true,
      conversationId: 'conv123',
      priorMessages: [
        { question: 'What is AI?', answer: 'AI is artificial intelligence.' },
      ],
    };

    it('should successfully proxy request to external API and return response', async () => {
      const mockExternalResponse = {
        conversation_id: 'conv123',
        answer: 'Paris is the capital of France.',
        history: [
          { question: 'What is AI?', answer: 'AI is artificial intelligence.' },
          { question: 'What is the capital of France?', answer: 'Paris is the capital of France.' },
        ],
        metadata: {
          usage: 'test',
          retriever_resources: [],
        },
      };

      // Mock login response
      mockedAxios.post
        .mockResolvedValueOnce({
          data: { access_token: 'mock_token' },
        })
        // Mock chat response
        .mockResolvedValueOnce({
          data: mockExternalResponse,
        });

      const result = await service.processBlocking(mockRequest);

      expect(mockedAxios.post).toHaveBeenCalledTimes(2);

      // Check login call
      expect(mockedAxios.post).toHaveBeenNthCalledWith(
        1,
        'https://test1.nlp-lab.ir/auth/login',
        'grant_type=password&username=kalate&password=12&scope=&client_id=&client_secret=',
        {
          headers: {
            accept: 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        }
      );

      // Check chat call
      expect(mockedAxios.post).toHaveBeenNthCalledWith(
        2,
        'https://test1.nlp-lab.ir/chat/',
        {
          query: mockRequest.query,
          inputs: {
            similarity_threshold: mockRequest.inputs.similarityThreshold,
            context_count: mockRequest.inputs.contextCount,
          },
          conversation_id: mockRequest.conversationId,
          prior_messages: mockRequest.priorMessages,
        },
        {
          headers: {
            accept: 'application/json',
            Authorization: 'Bearer mock_token',
            'Content-Type': 'application/json',
          },
        }
      );

      expect(result).toEqual(mockExternalResponse);
    });

    it('should handle login failure and return error', async () => {
      const loginError = new Error('Login failed');
      mockedAxios.post.mockRejectedValueOnce(loginError);

      const result = await service.processBlocking(mockRequest);

      expect(result).toEqual({
        event: 'error',
        error: {
          status: 500,
          code: 'LOGIN_ERROR',
          message: 'Login failed',
        },
        taskId: expect.any(String),
      });
    });

    it('should handle chat API failure and return error', async () => {
      const chatError = new Error('Chat API failed');
      mockedAxios.post
        .mockResolvedValueOnce({ data: { access_token: 'mock_token' } })
        .mockRejectedValueOnce(chatError);

      const result = await service.processBlocking(mockRequest);

      expect(result).toEqual({
        event: 'error',
        error: {
          status: 500,
          code: 'CHAT_ERROR',
          message: 'Chat API failed',
        },
        taskId: expect.any(String),
      });
    });

    it('should handle empty priorMessages array', async () => {
      const requestWithoutPrior = { ...mockRequest, priorMessages: undefined };
      const mockExternalResponse = {
        conversation_id: '',
        answer: 'Paris is the capital.',
        history: [],
        metadata: { usage: 'test', retriever_resources: [] },
      };

      mockedAxios.post
        .mockResolvedValueOnce({ data: { access_token: 'mock_token' } })
        .mockResolvedValueOnce({ data: mockExternalResponse });

      const result = await service.processBlocking(requestWithoutPrior);

      expect(mockedAxios.post).toHaveBeenNthCalledWith(
        2,
        'https://test1.nlp-lab.ir/chat/',
        expect.objectContaining({
          prior_messages: [],
        }),
        expect.any(Object)
      );

      expect(result).toEqual(mockExternalResponse);
    });

    it('should handle HTTP error responses with status codes', async () => {
      const httpError = {
        response: {
          status: 401,
          data: { detail: 'Unauthorized' },
        },
      };
      mockedAxios.post.mockRejectedValueOnce(httpError);

      const result = await service.processBlocking(mockRequest);

      expect(result).toEqual({
        event: 'error',
        error: {
          status: 401,
          code: 'LOGIN_ERROR',
          message: 'Unauthorized',
        },
        taskId: expect.any(String),
      });
    });
  });

  describe('processStreaming', () => {
    const mockRequest: ChatMessagesRequestDto = {
      query: 'What is AI?',
      inputs: {
        similarityThreshold: '0.8',
        contextCount: 3,
      },
      responseMode: ChatMessagesResponseMode.STREAMING,
      user: '507f1f77bcf86cd799439013',
      autoGeneratedName: true,
    };

    it('should proxy request and broadcast final result via gateway', async () => {
      const mockExternalResponse = {
        conversation_id: 'stream123',
        answer: 'AI stands for Artificial Intelligence.',
        history: [{ question: 'What is AI?', answer: 'AI stands for Artificial Intelligence.' }],
        metadata: { usage: 'streaming', retriever_resources: [] },
      };

      mockedAxios.post
        .mockResolvedValueOnce({ data: { access_token: 'mock_token' } })
        .mockResolvedValueOnce({ data: mockExternalResponse });

      const result = await service.processStreaming(mockRequest);

      expect(mockedAxios.post).toHaveBeenCalledTimes(2);
      expect(mockGateway.broadcast).toHaveBeenCalledWith({
        event: 'message_end',
        taskId: expect.any(String),
        ...mockExternalResponse,
        created_at: expect.any(String),
      });
      expect(result).toEqual({ taskId: expect.any(String) });
    });

    it('should handle streaming errors and broadcast error event', async () => {
      const chatError = new Error('Streaming failed');
      mockedAxios.post
        .mockResolvedValueOnce({ data: { access_token: 'mock_token' } })
        .mockRejectedValueOnce(chatError);

      const result = await service.processStreaming(mockRequest);

      expect(mockGateway.broadcast).toHaveBeenCalledWith({
        event: 'error',
        taskId: expect.any(String),
        conversation_id: mockRequest.conversationId || 'unknown',
        answer: '',
        status: 500,
        code: 'CHAT_ERROR',
        message: 'Streaming failed',
        created_at: expect.any(String),
      });
      expect(result).toEqual({ taskId: expect.any(String) });
    });
  });
});